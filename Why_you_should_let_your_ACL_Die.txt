Why you should let your ACL Die

Don't get me wrong ACLs still have their place on the file system, but they don't translate well to modern business applications, and web applications. Traditional file system ACLs were designed to be quick, efficient and simple. They are just stored as bits in a files meta data. However when you move to something like a web application, you're not dealing with file permissions, but business logic as applied to data, usually stored in some kind of database. This is why ACLs don't cut it, because you can't cram your business logic into a simple ACL. What I mean by business logic, is being able to check not only permission, but other information, that can be stored some where else(another service/class, database, ldap, etc), and be able to check that info based on any form of comparison(equals, date, greater than, less than, etc). Now there are those who will say that if you can't cram it into and ACL, it's not proper security, which I think is wrong. Since ACLs can't handle the business logic used to secure data in a web application, I think they are the wrong abstraction/tool for the job, because what you will end up doing is hacking your business logic in, and  around your ACL to supplement, it's short comings.  

Before I go any further, I would like to ask you, to try not judging, based on the language, and frame works used, but on the ideas.I would be very happy if you stole the ideas, that I'm going to put forth and use/apply/adapt them to what ever language/framework you use.

I came to the conclusion that ACLs weren't working for me in web applications a while ago.  In a previous project I was using Spring Security Core, and Spring Security ACL, in a Grails application, and I had about 1200 containers, which had about 400,000 ACL entries. I knew that with an up coming project, that the number of containers were going to grow exponentially. So I saw a problem, not just with scaling, but with managing that many ACLs. The ACLs were stored in a very normalized database form, with the permissions in a fake bit mask. So to query for who had what permission looked like a 500 word essay(single spaced). So with the new project I know that I would have to deal with more complicated business rules, and in spring security it's application of the permissions was through annotations, that used a spring EL language, that wasn't very flexible, without extra pain trying to extend it. Another issue I had, was that with the Spring Security ACL annotation, was that if you called a method with the annotation from within the same class that method was in, the annotation wasn't fired, which can lead to false negatives/security holes. The last issue I had with Spring security ACL was that it wasn't very easy to unit test.

So recently I released a Grails plug-in that deals with the issues I have with ACLs, called Enforcer. Enforcer provides a method annotation, that takes up to 3 closures(anonymous function in other languages). The annotation really just delegates to a service, that, evaluates the first closure(predicate), and it the result is false, then the second closure(failure closure) is executed or if not provided, an exception is thrown.  If the first closure(predicate) results true, then the third closure(success closure) is evaluated or if none is provided than an empty closure is executed, and you are let in the method. The closures allow me to execute any type of business logic I need, calling other services or mixing in logic with traits(Groovy's version of mixins).  For the default implementation. I provided a domainRole domain/model, which is set-up to have a hierarchy, and stored in a denormalized form, with a string representing the role.  This cuts the amount of rows need to be store to protect data, by an order of magnitude, and makes those roles easy to query, and read.  So in the default implementation, I'm using a string for the domainRole name, not a bit. I figured it's 2015 we can handle storing, and checking a string, like we do for system level roles, because disk is cheap, and maintainability is very important. The Enforcer annotation gets run every time the method it's annotating  is called, so no false negatives. The annotation is also very easy to test, by mocking a configuration, in a unit test.

So I'm hoping this inspires someone to take these ideas, and apply them to other languages and frameworks. The code and documentation for the Grails Enforcer Plug-in can be found here:
https://github.com/virtualdogbert/Enforcer
http://virtualdogbert.github.io/Enforcer/guide/introduction.html

These ideas were originally inspired by experience, and Zed Shaw's presentation, "The ACL is Dead". Zed does go off on tangents, and uses sarcasm, but I still think it's worth watching:
https://vimeo.com/2723800