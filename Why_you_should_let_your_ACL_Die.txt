Why you should let your ACL Die

Don't get me wrong ACLs still have their place on the file system, but they don't translate well to modern business applications, and web applications. Traditional file system ACLs were designed to be quick, efficient and simple. They are just stored as bits in a files meta data. However when you move to something like a web application, you're not dealing with file permission, but business logic as applied to data, usually stored is some kind of database. This is why ACLs don't cut it, because you can't cram your business logic into a simple ACL. Now there are those who will say that if you can't cram it into and ACL, it's not proper security, which I think is wrong. Since ACLs can't handle the business logic used to secure data in a web application, I think they are the wrong abstraction / tool for the job, because what you will end up doing is hacking your business logic in around your ACL to supplement.  

Before I go any further, I would like to ask you, to try not judging, based on the language and frame works used, but on the ideas.I would be very happy if you stole the ideas, that I'm going to put forth and use / apply / adapt them to what ever language / framework you use.

I came to the conclusion that ACLs weren't working for me in web applications a while ago.  In a previous project I was using Spring Security, in a Grails application, and I had about 1200 containers, which had about 400,000 ACL entries. I knew that with an up coming project, that the number of containers were going to grow exponentially. So I saw a problem, not just with scaling, but with managing that many ACLs. The ACLs were stored in a very normalized database form, with the permissions in a fake bit mask. So to query for who had what permission looked like a 500 work essay(single spaced). So with the new project I know that I would have to deal with more complicated business rules, and in spring security it's application of the permissions was through annotations, that used a spring EL language, that wasn't very flexible, without extra pain trying to extend it.

So recently I released a Grails plug-in that deals with the issues I have with ACLs, called Enforcer. Enforcer provides a method annotation, that takes up to 3 closures(antonymous function in other languages). The annotation really just delegates to a service, that, evaluates the first closure, and it the result is false, then the second closure is executed or if not provided, an exception is thrown.  If the first closure results true, then the third closure is evaluated or if none is provided than an empty closure is executed, and you are let in the method. The closures allow me to execute any type of business logic I need, calling other services or mixing in logic with traits(Groovy's version of mixins).  For the default implementation. I provided a domain/model role, which is set-up to have a hierarchy, stored in a denormalized form, with a string representing the role.  This cuts the amount of rows need to be store to protect data by an order of magnitude, makes those role easy to query and read.  So in the default I'm using a string for the domain role name, not a bit, I figured it's 2015 we can handle storing and checking a string, like we do for system level roles, because disk is cheap, and maintainability is very important, plus I save an order of magnitude in rows stored.

So I'm hoping this inspires someone to take these ideas, and apply them to other languages and frameworks. The code and documentation for the Grails Enforce Plug-in can be found here:
https://github.com/virtualdogbert/Enforcer
http://virtualdogbert.github.io/Enforcer/guide/introduction.html

These ideas were original inspired by experience and Zed Shaw's presentation, "The ACL is Dead". Zed does go off on tangents, and uses sarcasm, but I still think it's worth watching:
https://vimeo.com/2723800